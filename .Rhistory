summary(o1)
o2<-lm(btc_Price~Radeon.RX.6700.XT)
summary(o2)
o3<-lm(GeForce.RTX.3090~btc_Price)
o4<-lm(Radeon.RX.6700.XT~btc_Price)
summary(o3)
summary(o4)
o5<-lm(btc_Price~GeForce.RTX.3090+Radeon.RX.6700.XT)
summary(o5)
summary(o1)
summary(o5)
install.packages("datarium")
library(datarium)
data("marketing")
head(marketing)
round(cor(marketing),2)
attach(marketing)
#create linear regression model - summarize data
o1<-lm(sales~youtube)
summary(o1) #observe the p-value of the f-stat first
o3<-lm(btc_Price~Radeon.RX.6900.XT)
summary(o3)
o7<-lm(btc_Price~GeForce.RTX.3090+Radeon.RX.6900.XT)
summary(o7)
o1<-lm(sales~youtube)
summary(o1) #observe the p-value of the f-stat first
o2<-lm(sales~youtube+facebook)
summary(o2)
o6<-lm(btc_Price~Radeon.RX.6700.XT+GeForce.RTX.3090)
summary(o6)
o7<-lm(btc_Price~GeForce.RTX.3090+Radeon.RX.6900.XT)
summary(o7)
o4<-lm(GeForce.RTX.3090~btc_Price)
o5<-lm(Radeon.RX.6700.XT~btc_Price)
summary(o5)
summary(o4)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
head(mktsamples)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
head(mktsamples)
round(cor(mktsamples),4)
attach(mktsamples)
round(cor(mktsamples),4)
round(cor(mktsamples[c(-1,-3)]),4)
real<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/RealEstate.txt",sep="\t",header=TRUE)
attach(real)
cor(real[c(-1,-4,-6,-7)])
round(cor(mktsamples[c(-1)]),4)
o1<-lm(eBay.Price~btc_Prices)
summary(o1)
o1<-lm(btc_Prices~eBay.Price)
summary(o1)
o1<-lm(btc_Prices~eBay.Price+factor(GPU))
summary(o1)
o1<- summary(lm(Price~Size))
o1
factor<-summary(lm(Price~Size+factor(Area)))
factor
o1<-lm(btc_Prices~eBay.Price+factor(GPU))
factor
summary(o1)
factor
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
summary(mktsamples)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
round(cor(mktsamples[c(-1)])1)
round(cor(mktsamples[c(-1)]),2)
cor(mktsamples[c(-1)])
round(cor(mktsamples[c(-1)]),)
o1<-lm(btc_Prices~eBay.Price+factor(GPU))
summary(o1)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
o1<-lm(btc_Prices~eBay.Price+factor(GPU))
summary(o1)
o1<-lm(eBay.Price~btc_Prices+factor(GPU))
summary(o1)
o1<-lm(eBay.Price~btc_Prices)
summary(o1)
o1<-lm(eBay.Price~btc_Prices+factor(GPU))
summary(o1)
factor<-lm(eBay.Price~btc_Prices+factor(GPU))
plot(eBay.Price~btc_Prices)
abline(a=mean(eBay.Price),b=0,col="green")
o1<-lm(eBay.Price~btc_Prices)
summary(o1)
install.packages("datarium")
library(datarium)
data("marketing")
head(marketing)
round(cor(marketing),2)
attach(marketing)
#create linear regression model - summarize data
o1<-lm(sales~youtube)
summary(o1) #observe the p-value of the f-stat first
install.packages("datarium")
summary(o1) #observe the p-value of the f-stat first
o1<-lm(eBay.Price~btc_Prices)
summary(o1)
o1<-lm(sales~youtube)
summary(o1) #observe the p-value of the f-stat first
o1<-lm(eBay.Price~btc_Prices)
summary(o1)
130.70*1000
o2<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
summary(mktsamples)
plot(eBay.Price~btc_Prices)
abline(a=mean(eBay.Price),b=0,col="green")
#predict and residual equations
o2<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
#residuals vs predicted, are the residuals' variance increasing/decreasing or constant?
plot(ro2~o2,xlab="predicted",ylab="Residuals")
#create residuals vs fitted
o<-lm(eBay.Price~btc_Prices+factor(GPU))
plot(o)
o1<-lm(btc_Price~GeForce.RTX.3090)#powerhouse,work-horse
resale<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktData.csv",sep=',',header = TRUE)
attach(resale)
head(resale)
round(cor(resale[c(-1,-2)]),4) #positive correlation between btc_Price and given gpu Price
summary(resale)
o1<-lm(btc_Price~GeForce.RTX.3090)#powerhouse,work-horse
s1<-summary(o1)
o2<-lm(btc_Price~Radeon.RX.6700.XT)#durability, and efficient, all at a good price
s2<-summary(o2)
s1
o6<-lm(btc_Price~Radeon.RX.6700.XT+GeForce.RTX.3090)
summary(o6)
o4<-lm(GeForce.RTX.3090~btc_Price)
summary(o4)
o5<-lm(Radeon.RX.6700.XT~btc_Price)
summary(o5)
o5<-lm(Radeon.RX.6700.XT~btc_Price+factor(month))
summary(o5)
o5<-lm(Radeon.RX.6700.XT~btc_Price+factor(Unix.Epoch.Time))
summary(o5)
resale<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktData.csv",sep=',',header = TRUE)
attach(resale)
head(resale)
round(cor(resale[c(-1,-2)]),4) #positive correlation between btc_Price and given gpu Price
summary(resale)
round(cor(mktsamples[c(-1)]),4)
o2<-lm(eBay.Price~btc_Prices+QTY.Sold)
summary(o2)
o2<-lm(eBay.Price~btc_Prices+QTY.Sold+factor(GPU))
summary(o2)
factor
factor<-lm(eBay.Price~btc_Prices+factor(GPU))
factor
summary(factor)
#GPU eBAY Price relative to bitcoin Price
plot(eBay.Price~btc_Prices)
abline(a=mean(eBay.Price),b=0,col="green")
#predict and residual equations
o2<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
#residuals vs predicted, are the residuals' variance increasing/decreasing or constant?
plot(ro2~o2,xlab="predicted",ylab="Residuals")
#create residuals vs fitted
o1<-lm(eBay.Price~btc_Prices+factor(GPU))
o2<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
plot(ro2~o2,xlab="predicted",ylab="Residuals")
plot(o1)
o1<-lm(btc_Price~GeForce.RTX.3090)#powerhouse,work-horse
s1<-summary(o1)
o2<-lm(btc_Price~Radeon.RX.6700.XT)#durability, and efficient, all at a good price
s2<-summary(o2)
p1<-predict(o1)
p2<-predict(o2)
#residuals
r1<-residuals(o1)
r2<-residuals(o2)
plot(r1~p1,xlab="predicted",ylab="Residuals")
plot(r2~p1,xlab="predicted",ylab="Residuals")
plot(o1)
o1<-lm(eBay.Price~btc_Prices+factor(GPU))
plot(o1)
plot(ro2~o2,xlab="predicted",ylab="Residuals")
o2<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
plot(ro2~o2,xlab="predicted",ylab="Residuals")
p1<-predict(o1)
p2<-predict(o2)
plot(r1~p1,xlab="predicted",ylab="Residuals")
o1<-lm(btc_Price~GeForce.RTX.3090)#powerhouse,work-horse
s1<-summary(o1)
o2<-lm(btc_Price~Radeon.RX.6700.XT)#durability, and efficient, all at a good price
s2<-summary(o2)
p1<-predict(o1)
p2<-predict(o2)
#residuals
r1<-residuals(o1)
r2<-residuals(o2)
#increasing or decreasing variance? - Increasing/Decreasing , significantly. -> bad.
plot(r1~p1,xlab="predicted",ylab="Residuals")
plot(r2~p1,xlab="predicted",ylab="Residuals")
round(cor(mktsamples[c(-1)]),4)
o2<-lm(eBay.Price~btc_Prices+QTY.Sold)
summary(o2)
o1<-lm(eBay.Price~btc_Prices+factor(GPU))
summary(o1)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
summary(mktsamples)
o1<-lm(eBay.Price~btc_Prices)
summary(o1)
o2<-lm(eBay.Price~btc_Prices+QTY.Sold)
summary(o2)
f1<-lm(eBay.Price~btc_Prices+factor(GPU))
summary(f1)
summary(f2)
f2<-lm(eBay.Price~btc_Prices+QTY.Sold+factor(GPU))
summary(f2)
real<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/RealEstate.txt",sep="\t",header=TRUE)
#realestatedata
attach(real)
factor<-summary(lm(Price~Size+factor(Area)))
factor
mktsamples[mktsamples$GPU != 'GeForce RTX 3080','GeForce RTX 3080 T','GeForce RTX 3080 T','Radeon RX 6900 XT ' ]
mktsamples[mktsamples$GPU != 'GeForce RTX 3080','GeForce RTX 3080 T','GeForce RTX 3080 T','Radeon RX 6900 XT ', ]
mktsamples[mktsamples$GPU != 'GeForce RTX 3080','GeForce RTX 3080 T','GeForce RTX 3080 T', ]
mktsamples[mktsamples$GPU != 'GeForce RTX 3080','GeForce RTX 3080 T','GeForce RTX 3090','Radeon RX 6900 XT ', ]
mktsamples[mktsamples$GPU != 'GeForce RTX 3080','GeForce RTX 3080 T','GeForce RTX 3090', ]
mktsamples[mktsamples$GPU != 'GeForce RTX 3080', ]
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
summary(mktsamples)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
round(cor(mktsamples[c(-1)]),4)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
summary(mktsamples)
plot(eBay.Price~btc_Prices)
abline(a=mean(eBay.Price),b=0,col="green")
p1<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
#residuals vs predicted, are the residuals' variance increasing/decreasing or constant?
plot(ro2~p1,xlab="predicted",ylab="Residuals")
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
plot(eBay.Price~btc_Prices)
abline(a=mean(eBay.Price),b=0,col="green")
p1<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
plot(ro2~p1,xlab="predicted",ylab="Residuals")
plot(eBay.Price~btc_Prices)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
plot(eBay.Price~btc_Prices)
abline(a=mean(eBay.Price),b=0,col="green")
p1<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
plot(ro2~p1,xlab="predicted",ylab="Residuals")
f1<-lm(eBay.Price~btc_Prices+factor(GPU))
plot(f1)
o1<-lm(eBay.Price~btc_Prices)
#Let's say alpha = .05. H_null: bit coin prices have no affect on gpu ebay prices
summary(o1)
summary(f1)
o2<-lm(eBay.Price~btc_Prices+QTY.Sold)
summary(o2)
f2<-lm(eBay.Price~btc_Prices+QTY.Sold+factor(GPU))
summary(f2)
summary(f1)
summary(f2)
summary(o1)
plot(ro2~p1,xlab="predicted",ylab="Residuals")
plot(f1)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
summary(mktsamples)
plot(eBay.Price~btc_Prices)
abline(a=mean(eBay.Price),b=0,col="green")
p1<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
plot(ro2~p1,xlab="predicted",ylab="Residuals")
abline(a=mean(ro2),b=0,col='green')
f1<-lm(eBay.Price~btc_Prices+factor(GPU))
lillie.test(ro2)
require(nortest)
library(nortest)
#Null hypothesis is that the residuals are normally distributed
lillie.test(ro2)
acf(ro2) #passes assumption? residuals are independent? I think? Need help interpreting this...
plot(eBay.Price~btc_Prices)
#regression line that will help us predict values we have not observed
abline(a=lm(eBay.Price~btc_Prices),b=0,col='red')
o1<-lm(eBay.Price~btc_Prices)
o2<-lm(eBay.Price~btc_Prices+QTY.Sold)
K=50
MAE = array(dim=c(K))
MSE = array(dim=c(K))
out = array(dim=c(K))
for (i in 1:K){
randrows<- sample(1:nrow(mktsamples),nrow(mktsamples)*(0.7))
#randrows go into training, rest goes into test
training<-mktsamples[randrows,] #70% of the data to represent training
test<-mktsamples[-randrows,] #30% of the data to represent test
attach(training)
o=lm(eBay.Price~btc_Prices) #O does not contain any of the predictions, only the data we want to predict
predict(o,newdata = test)
#get eBay.Prices of test
attach(test)
#assuming we have a valid model, MAE will tell you how many errors on average
MAE[i]<-mean(abs(eBay.Price-predict(o,newdata = test)))
MSE[i]<-mean(abs(eBay.Price-predict(o,newdata = test))^2)
out[i]<-sum((eBay.Price<pred[,2])|(sales>pred[,3]))/length(sales)
}
predict(o,newdata = test, interval = "prediction")
pred<- predict(o,newdata = test, interval = "prediction")
MAE
MSE
pred
K=50
MAE = array(dim=c(K))
MSE = array(dim=c(K))
out = array(dim=c(K))
for (i in 1:K){
randrows<- sample(1:nrow(mktsamples),nrow(mktsamples)*(0.7))
#randrows go into training, rest goes into test
training<-mktsamples[randrows,] #70% of the data to represent training
test<-mktsamples[-randrows,] #30% of the data to represent test
attach(training)
o=lm(eBay.Price~btc_Prices+QTY.Sold+factor(GPU)) #O does not contain any of the predictions, only the data we want to predict
predict(o,newdata = test)
#get eBay.Prices of test
attach(test)
#assuming we have a valid model, MAE will tell you how many errors on average
MAE[i]<-mean(abs(eBay.Price-predict(o,newdata = test)))
MSE[i]<-mean(abs(eBay.Price-predict(o,newdata = test))^2)
out[i]<-sum((eBay.Price<pred[,2])|(eBay.Price>pred[,3]))/length(eBay.Price)
}
for (i in 1:K){
randrows<- sample(1:nrow(mktsamples),nrow(mktsamples)*(0.7))
#randrows go into training, rest goes into test
training<-mktsamples[randrows,] #70% of the data to represent training
test<-mktsamples[-randrows,] #30% of the data to represent test
attach(training)
o=lm(eBay.Price~btc_Prices+QTY.Sold+factor(GPU)) #O does not contain any of the predictions, only the data we want to predict
predict(o,newdata = test)
#get eBay.Prices of test
attach(test)
#assuming we have a valid model, MAE will tell you how many errors on average
MAE[i]<-mean(abs(eBay.Price-predict(o,newdata = test)))
MSE[i]<-mean(abs(eBay.Price-predict(o,newdata = test))^2)
out[i]<-sum((eBay.Price<pred[,2])|(eBay.Price>pred[,3]))/length(eBay.Price)
}
for (i in 1:K){
randrows<- sample(1:nrow(mktsamples),nrow(mktsamples)*(0.7))
#randrows go into training, rest goes into test
training<-mktsamples[randrows,] #70% of the data to represent training
test<-mktsamples[-randrows,] #30% of the data to represent test
attach(training)
o=lm(eBay.Price~btc_Prices+QTY.Sold+factor(GPU)) #O does not contain any of the predictions, only the data we want to predict
predict(o,newdata = test)
#get eBay.Prices of test
attach(test)
levels(droplevels('Radeon RX 6700 10GB'))
#assuming we have a valid model, MAE will tell you how many errors on average
MAE[i]<-mean(abs(eBay.Price-predict(o,newdata = test)))
MSE[i]<-mean(abs(eBay.Price-predict(o,newdata = test))^2)
out[i]<-sum((eBay.Price<pred[,2])|(eBay.Price>pred[,3]))/length(eBay.Price)
}
levels(droplevels('Radeon RX 6700 10GB'))
test
training
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
plot(eBay.Price~btc_Prices)
abline(a=mean(eBay.Price),b=0,col="green")
#Assumptions - Does our model violate any of the Linear Regression assumptions?
#predict and residual equations
p1<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
#residuals vs predicted, are the residuals' variance increasing/decreasing or constant?
plot(ro2~p1,xlab="predicted",ylab="Residuals")
abline(a=mean(ro2),b=0,col='green')
f1<-lm(eBay.Price~btc_Prices+factor(GPU))
o1<-lm(eBay.Price~btc_Prices)
o2<-lm(eBay.Price~btc_Prices+QTY.Sold)
K=50
MAE = array(dim=c(K))
MSE = array(dim=c(K))
out = array(dim=c(K))
for (i in 1:K){
randrows<- sample(1:nrow(mktsamples),nrow(mktsamples)*(0.7))
#randrows go into training, rest goes into test
training<-mktsamples[randrows,] #70% of the data to represent training
test<-mktsamples[-randrows,] #30% of the data to represent test
attach(training)
o=lm(eBay.Price~btc_Prices+QTY.Sold+factor(GPU)) #O does not contain any of the predictions, only the data we want to predict
predict(o,newdata = test)
#get eBay.Prices of test
attach(test)
levels(droplevels('Radeon RX 6700 10GB'))
#assuming we have a valid model, MAE will tell you how many errors on average
MAE[i]<-mean(abs(eBay.Price-predict(o,newdata = test)))
MSE[i]<-mean(abs(eBay.Price-predict(o,newdata = test))^2)
out[i]<-sum((eBay.Price<pred[,2])|(eBay.Price>pred[,3]))/length(eBay.Price)
}
mktsamples<-read.table(file="C:/Users/Jacne/Documents/python/visualization_and_datamining/data/dataminingProject/btc_gpu_mktSamples.csv",sep=',',header = TRUE)
attach(mktsamples)
head(mktsamples)
round(cor(mktsamples[c(-1)]),4)
p1<-predict(lm(eBay.Price~btc_Prices))
ro2<-residuals(lm(eBay.Price~btc_Prices))
#residuals vs predicted, are the residuals' variance increasing/decreasing or constant?
plot(ro2~p1,xlab="predicted",ylab="Residuals")
abline(a=mean(ro2),b=0,col='green')
f1<-lm(eBay.Price~btc_Prices+factor(GPU))
plot(eBay.Price~btc_Prices)
#regression line that will help us predict values we have not observed
abline(a=lm(eBay.Price~btc_Prices),b=0,col='red')
#Linear Regression Model - Summarize data
o1<-lm(eBay.Price~btc_Prices)
o2<-lm(eBay.Price~btc_Prices+QTY.Sold)
f2<-lm(eBay.Price~btc_Prices+QTY.Sold+factor(GPU))
K=50
MAE = array(dim=c(K))
MSE = array(dim=c(K))
out = array(dim=c(K))
for (i in 1:K){
randrows<- sample(1:nrow(mktsamples),nrow(mktsamples)*(0.7))
#randrows go into training, rest goes into test
training<-mktsamples[randrows,] #70% of the data to represent training
test<-mktsamples[-randrows,] #30% of the data to represent test
attach(training)
o=lm(eBay.Price~btc_Prices+QTY.Sold+factor(GPU)) #O does not contain any of the predictions, only the data we want to predict
predict(o,newdata = test)
#get eBay.Prices of test
attach(test)
levels(droplevels('Radeon RX 6700 10GB'))
#assuming we have a valid model, MAE will tell you how many errors on average
MAE[i]<-mean(abs(eBay.Price-predict(o,newdata = test)))
MSE[i]<-mean(abs(eBay.Price-predict(o,newdata = test))^2)
out[i]<-sum((eBay.Price<pred[,2])|(eBay.Price>pred[,3]))/length(eBay.Price)
}
K=50
MAE = array(dim=c(K))
MSE = array(dim=c(K))
out = array(dim=c(K))
for (i in 1:K){
randrows<- sample(1:nrow(mktsamples),nrow(mktsamples)*(0.7))
#randrows go into training, rest goes into test
training<-mktsamples[randrows,] #70% of the data to represent training
test<-mktsamples[-randrows,] #30% of the data to represent test
attach(training)
o=lm(eBay.Price~btc_Prices+QTY.Sold+factor(GPU)) #O does not contain any of the predictions, only the data we want to predict
predict(o,newdata = test)
#get eBay.Prices of test
attach(test)
#assuming we have a valid model, MAE will tell you how many errors on average
MAE[i]<-mean(abs(eBay.Price-predict(o,newdata = test)))
MSE[i]<-mean(abs(eBay.Price-predict(o,newdata = test))^2)
out[i]<-sum((eBay.Price<pred[,2])|(eBay.Price>pred[,3]))/length(eBay.Price)
}
